package replstore

import (
    "errors"
    "fmt"
    "sync"
    "time"

    "github.com/gholt/ring"
    "github.com/gholt/store"
    "github.com/pandemicsyn/oort/api"
)

type Repl{{.T}}Store struct {
    addressIndex int

    ringLock sync.RWMutex
    ring ring.Ring

    storesLock sync.RWMutex
    stores map[string]*repl{{.T}}StoreAndTicketChan
}

type repl{{.T}}StoreAndTicketChan struct {
    store      store.{{.T}}Store
    ticketChan chan struct{}
}

func NewRepl{{.T}}Store(c *Repl{{.T}}StoreConfig) *Repl{{.T}}Store {
    cfg := resolveRepl{{.T}}StoreConfig(c)
    return &Repl{{.T}}Store{addressIndex: cfg.AddressIndex}
}

func (rs *Repl{{.T}}Store) Ring() ring.Ring {
    rs.ringLock.RLock()
    r := rs.ring
    rs.ringLock.RUnlock()
    return r
}

func (rs *Repl{{.T}}Store) SetRing(r ring.Ring) {
    rs.ringLock.Lock()
    rs.ring = r
    rs.ringLock.Unlock()
    nodes := r.Nodes()
    currentAddrs := make(map[string]struct{}, len(nodes))
    for _, n := range nodes {
        currentAddrs[n.Address(rs.addressIndex)] = struct{}{}
    }
    var shutdownAddrs []string
    rs.storesLock.RLock()
    for a := range rs.stores {
        if _, ok := currentAddrs[a]; !ok {
            shutdownAddrs = append(shutdownAddrs, a)
        }
    }
    rs.storesLock.RUnlock()
    if len(shutdownAddrs) > 0 {
        shutdownStores := make([]*repl{{.T}}StoreAndTicketChan, len(shutdownAddrs))
        rs.storesLock.Lock()
        for i, a := range shutdownAddrs {
            shutdownStores[i] = rs.stores[a]
            rs.stores[a] = nil
        }
        rs.storesLock.Unlock()
        for _, s := range shutdownStores {
            if err := s.store.Shutdown(); err != nil {
                // TODO: debug log the err for completeness
            }
        }
    }
}

func (rs *Repl{{.T}}Store) storesFor(keyA uint64) []*repl{{.T}}StoreAndTicketChan {
    rs.ringLock.RLock()
    r := rs.ring
    rs.ringLock.RUnlock()
    ns := r.ResponsibleNodes(uint32(keyA >> (64 - r.PartitionBitCount())))
    as := make([]string, len(ns))
    for i, n := range ns {
        as[i] = n.Address(rs.addressIndex)
    }
    ss := make([]*repl{{.T}}StoreAndTicketChan, len(ns))
    var someNil bool
    rs.storesLock.RLock()
    for i := len(ss) - 1; i >= 0; i-- {
        ss[i] = rs.stores[as[i]]
        if ss[i] == nil {
            someNil = true
        }
    }
    rs.storesLock.RUnlock()
    if someNil {
        rs.storesLock.Lock()
        for i := len(ss) - 1; i >= 0; i-- {
            if ss[i] == nil {
                ss[i] = rs.stores[as[i]]
                if ss[i] == nil {
                    var err error
                    // TODO: The 10 here is arbitrary.
                    tc := make(chan struct{}, 10)
                    for i := cap(tc); i > 0; i-- {
                        tc <- struct{}{}
                    }
                    ss[i] = &repl{{.T}}StoreAndTicketChan{ticketChan: tc}
                    // TODO: The 10 here is arbitrary (and unrelated to the
                    // above arbitrary 10).
                    ss[i].store, err = api.New{{.T}}Store(as[i], 10)
                    if err != nil {
                        ss[i].store = error{{.T}}Store(fmt.Sprintf("could not create store for %s: %s", as[i], err))
                        go func(addr string) {
                            rs.storesLock.Lock()
                            s := rs.stores[addr]
                            if s != nil {
                                if _, ok := s.store.(error{{.T}}Store); ok {
                                    rs.stores[addr] = nil
                                }
                            }
                            rs.storesLock.Unlock()
                        }(as[i])
                    }
                    rs.stores[as[i]] = ss[i]
                }
            }
        }
        rs.storesLock.Unlock()
    }
    return ss
}

func (rs *Repl{{.T}}Store) Startup() error {
    return nil
}

func (rs *Repl{{.T}}Store) Shutdown() error {
    return nil
}

func (rs *Repl{{.T}}Store) EnableWrites() error {
    return nil
}

func (rs *Repl{{.T}}Store) DisableWrites() error {
    return errors.New("cannot disable writes with this client at this time")
}

func (rs *Repl{{.T}}Store) Flush() error {
    return nil
}

func (rs *Repl{{.T}}Store) AuditPass() error {
    return errors.New("audit passes not available with this client at this time")
}

func (rs *Repl{{.T}}Store) Stats(debug bool) (fmt.Stringer, error) {
    return noStats, nil
}

func (rs *Repl{{.T}}Store) ValueCap() (uint32, error) {
    return 0xffffffff, nil
}

func (rs *Repl{{.T}}Store) Lookup(keyA, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}) (int64, uint32, error) {
    type rettype struct {
        timestampMicro int64
        length         uint32
        err            Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    stores := rs.storesFor(keyA)
    for _, s := range stores {
        go func(s *repl{{.T}}StoreAndTicketChan) {
            ret := &rettype{}
            var err error
            select {
            case <-s.ticketChan:
                ret.timestampMicro, ret.length, err = s.store.Lookup(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}})
                s.ticketChan <- struct{}{}
            case <-time.After(time.Second):
                // TODO: That time.Second above is arbitrary.
                err = timeoutErr
            }
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s.store, err: err}
            }
            ec <- ret
        }(s)
    }
    var timestampMicro int64
    var length uint32
    var errs Repl{{.T}}StoreErrorSlice
    var notFounds int
    // TODO: Selection algorithms
    for _ = range stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
            if store.IsNotFound(ret.err) {
                notFounds++
            }
        } else if ret.timestampMicro > timestampMicro {
            timestampMicro = ret.timestampMicro
            length = ret.length
        }
    }
    if notFounds > 0 {
        nferrs := make(Repl{{.T}}StoreErrorNotFound, len(errs))
        for i, v := range errs {
            nferrs[i] = v
        }
        return timestampMicro, length, nferrs
    }
    return timestampMicro, length, errs
}

func (rs *Repl{{.T}}Store) Read(keyA uint64, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}, value []byte) (int64, []byte, error) {
    type rettype struct {
        timestampMicro int64
        value          []byte
        err            Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    stores := rs.storesFor(keyA)
    for _, s := range stores {
        go func(s *repl{{.T}}StoreAndTicketChan) {
            ret := &rettype{}
            var err error
            select {
            case <-s.ticketChan:
                ret.timestampMicro, ret.value, err = s.store.Read(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}}, nil)
                s.ticketChan <- struct{}{}
            case <-time.After(time.Second):
                // TODO: That time.Second above is arbitrary.
                err = timeoutErr
            }
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s.store, err: err}
            }
            ec <- ret
        }(s)
    }
    var timestampMicro int64
    var rvalue []byte
    var errs Repl{{.T}}StoreErrorSlice
    var notFounds int
    // TODO: Selection algorithms
    for _ = range stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
            if store.IsNotFound(ret.err) {
                notFounds++
            }
        } else if ret.timestampMicro > timestampMicro {
            timestampMicro = ret.timestampMicro
            rvalue = ret.value
        }
    }
    if value != nil && rvalue != nil {
        rvalue = append(value, rvalue...)
    }
    if notFounds > 0 {
        nferrs := make(Repl{{.T}}StoreErrorNotFound, len(errs))
        for i, v := range errs {
            nferrs[i] = v
        }
        return timestampMicro, rvalue, nferrs
    }
    return timestampMicro, rvalue, errs
}

func (rs *Repl{{.T}}Store) Write(keyA uint64, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}, timestampMicro int64, value []byte) (int64, error) {
    type rettype struct {
        oldTimestampMicro int64
        err               Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    stores := rs.storesFor(keyA)
    for _, s := range stores {
        go func(s *repl{{.T}}StoreAndTicketChan) {
            ret := &rettype{}
            var err error
            select {
            case <-s.ticketChan:
                ret.oldTimestampMicro, err = s.store.Write(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}}, timestampMicro, value)
                s.ticketChan <- struct{}{}
            case <-time.After(time.Second):
                // TODO: That time.Second above is arbitrary.
                err = timeoutErr
            }
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s.store, err: err}
            }
            ec <- ret
        }(s)
    }
    var oldTimestampMicro int64
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if ret.oldTimestampMicro > oldTimestampMicro {
            oldTimestampMicro = ret.oldTimestampMicro
        }
    }
    return oldTimestampMicro, errs
}

func (rs *Repl{{.T}}Store) Delete(keyA uint64, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}, timestampMicro int64) (int64, error) {
    type rettype struct {
        oldTimestampMicro int64
        err               Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    stores := rs.storesFor(keyA)
    for _, s := range stores {
        go func(s *repl{{.T}}StoreAndTicketChan) {
            ret := &rettype{}
            var err error
            select {
            case <-s.ticketChan:
                ret.oldTimestampMicro, err = s.store.Delete(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}}, timestampMicro)
                s.ticketChan <- struct{}{}
            case <-time.After(time.Second):
                // TODO: That time.Second above is arbitrary.
                err = timeoutErr
            }
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s.store, err: err}
            }
            ec <- ret
        }(s)
    }
    var oldTimestampMicro int64
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if ret.oldTimestampMicro > oldTimestampMicro {
            oldTimestampMicro = ret.oldTimestampMicro
        }
    }
    return oldTimestampMicro, errs
}

{{if eq .t "group"}}
func (rs *Repl{{.T}}Store) LookupGroup(parentKeyA, parentKeyB uint64) ([]store.LookupGroupItem, error) {
    type rettype struct {
        items []store.LookupGroupItem
        err   Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    stores := rs.storesFor(parentKeyA)
    for _, s := range stores {
        go func(s *repl{{.T}}StoreAndTicketChan) {
            ret := &rettype{}
            var err error
            select {
            case <-s.ticketChan:
                ret.items, err = s.store.LookupGroup(parentKeyA, parentKeyB)
                s.ticketChan <- struct{}{}
            case <-time.After(time.Second):
                // TODO: That time.Second above is arbitrary.
                err = timeoutErr
            }
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s.store, err: err}
            }
            ec <- ret
        }(s)
    }
    var items []store.LookupGroupItem
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if len(ret.items) > len(items) {
            items = ret.items
        }
    }
    return items, errs
}

func (rs *Repl{{.T}}Store) ReadGroup(parentKeyA, parentKeyB uint64) ([]store.ReadGroupItem, error) {
    type rettype struct {
        items []store.ReadGroupItem
        err   Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    stores := rs.storesFor(parentKeyA)
    for _, s := range stores {
        go func(s *repl{{.T}}StoreAndTicketChan) {
            ret := &rettype{}
            var err error
            select {
            case <-s.ticketChan:
                ret.items, err = s.store.ReadGroup(parentKeyA, parentKeyB)
                s.ticketChan <- struct{}{}
            case <-time.After(time.Second):
                // TODO: That time.Second above is arbitrary.
                err = timeoutErr
            }
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s.store, err: err}
            }
            ec <- ret
        }(s)
    }
    var items []store.ReadGroupItem
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if len(ret.items) > len(items) {
            items = ret.items
        }
    }
    return items, errs
}
{{end}}

type Repl{{.T}}StoreError interface {
    error
    Store() store.{{.T}}Store
    Err()   error
}

type Repl{{.T}}StoreErrorSlice []Repl{{.T}}StoreError

func (es Repl{{.T}}StoreErrorSlice) Error() string {
    if len(es) <= 0 {
        return "unknown error"
    } else if len(es) == 1 {
        return es[0].Error()
    }
    return fmt.Sprintf("%d errors, first is: %s", len(es), es[0])
}

type Repl{{.T}}StoreErrorNotFound Repl{{.T}}StoreErrorSlice

func (e Repl{{.T}}StoreErrorNotFound) Error() string {
    if len(e) <= 0 {
        return "unknown error"
    } else if len(e) == 1 {
        return e[0].Error()
    }
    return fmt.Sprintf("%d errors, first is: %s", len(e), e[0])
}

func (e Repl{{.T}}StoreErrorNotFound) ErrorNotFound() string {
    return e.Error()
}

type repl{{.T}}StoreError struct {
    store store.{{.T}}Store
    err error
}

func (e *repl{{.T}}StoreError) Error() string {
    if e.err == nil {
        return "unknown error"
    }
    return e.err.Error()
}

func (e *repl{{.T}}StoreError) Store() store.{{.T}}Store {
    return e.store
}

func (e *repl{{.T}}StoreError) Err() error {
    return e.err
}
