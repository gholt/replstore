package replstore

import (
    "fmt"
    "math"

    "github.com/gholt/store"
)

type Repl{{.T}}Store struct {
    Stores []store.{{.T}}Store
}

type Repl{{.T}}StoreError interface {
    error
    Store() store.{{.T}}Store
    Err()   error
}

type Repl{{.T}}StoreErrorSlice []Repl{{.T}}StoreError

func (es Repl{{.T}}StoreErrorSlice) Error() string {
    if len(es) <= 0 {
        return "unknown error"
    } else if len(es) == 1 {
        return es[0].Error()
    }
    return fmt.Sprintf("%d errors, first is: %s", len(es), es[0])
}

type Repl{{.T}}StoreErrorNotFound Repl{{.T}}StoreErrorSlice

func (e Repl{{.T}}StoreErrorNotFound) Error() string {
    if len(e) <= 0 {
        return "unknown error"
    } else if len(e) == 1 {
        return e[0].Error()
    }
    return fmt.Sprintf("%d errors, first is: %s", len(e), e[0])
}

func (e Repl{{.T}}StoreErrorNotFound) ErrorNotFound() string {
    return e.Error()
}

type repl{{.T}}StoreError struct {
    store store.{{.T}}Store
    err error
}

func (e *repl{{.T}}StoreError) Error() string {
    if e.err == nil {
        return "unknown error"
    }
    return e.err.Error()
}

func (e *repl{{.T}}StoreError) Store() store.{{.T}}Store {
    return e.store
}

func (e *repl{{.T}}StoreError) Err() error {
    return e.err
}

func (rs *Repl{{.T}}Store) helper(f func(s store.{{.T}}Store) error) error {
    ec := make(chan Repl{{.T}}StoreError)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            if err := f(s); err != nil {
                ec <- &repl{{.T}}StoreError{store: s, err: err}
            } else {
                ec <- nil
            }
        }(s)
    }
    var errs Repl{{.T}}StoreErrorSlice
    for _ = range rs.Stores {
        if err := <-ec; err != nil {
            errs = append(errs, err)
        }
    }
    if len(errs) > 0 {
        return errs
    }
    return nil
}

func (rs *Repl{{.T}}Store) Startup() error {
    return rs.helper(func(s store.{{.T}}Store) error { return s.Startup() })
}

func (rs *Repl{{.T}}Store) Shutdown() error {
    return rs.helper(func(s store.{{.T}}Store) error { return s.Shutdown() })
}

func (rs *Repl{{.T}}Store) EnableWrites() error {
    return rs.helper(func(s store.{{.T}}Store) error { return s.EnableWrites() })
}

func (rs *Repl{{.T}}Store) DisableWrites() error {
    return rs.helper(func(s store.{{.T}}Store) error { return s.DisableWrites() })
}

func (rs *Repl{{.T}}Store) Flush() error {
    return rs.helper(func(s store.{{.T}}Store) error { return s.Flush() })
}

func (rs *Repl{{.T}}Store) AuditPass() error {
    return rs.helper(func(s store.{{.T}}Store) error { return s.AuditPass() })
}

type Repl{{.T}}StoreStats interface {
    fmt.Stringer
    Store() store.{{.T}}Store
    Stats() fmt.Stringer
}

type repl{{.T}}StoreStats struct {
    store store.{{.T}}Store
    stats fmt.Stringer
}

func (s *repl{{.T}}StoreStats) Store() store.{{.T}}Store {
    return s.store
}

func (s *repl{{.T}}StoreStats) Stats() fmt.Stringer {
    return s.stats
}

func (s *repl{{.T}}StoreStats) String() string {
    if s.stats == nil {
        return "nil stats"
    }
    return s.stats.String()
}

type Repl{{.T}}StoreStatsSlice []Repl{{.T}}StoreStats

func (ss Repl{{.T}}StoreStatsSlice) String() string {
    if len(ss) <= 0 {
        return "nil stats"
    } else if len(ss) == 1 {
        return ss[0].String()
    }
    return fmt.Sprintf("%d stats, first is: %s", len(ss), ss[0])
}

func (rs *Repl{{.T}}Store) Stats(debug bool) (fmt.Stringer, error) {
    type rettype struct {
        stats Repl{{.T}}StoreStats
        err   Repl{{.T}}StoreError
    }
    retchan := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            stats, err := s.Stats(debug)
            ret := &rettype{}
            if stats != nil {
                ret.stats = &repl{{.T}}StoreStats{store: s, stats: stats}
            }
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s, err: err}
            }
            retchan <- ret
        }(s)
    }
    var stats Repl{{.T}}StoreStatsSlice
    var errs Repl{{.T}}StoreErrorSlice
    for _ = range rs.Stores {
        ret := <-retchan
        if ret.stats != nil {
            stats = append(stats, ret.stats)
        }
        if ret.err != nil {
            errs = append(errs, ret.err)
        }
    }
    return stats, errs
}

func (rs *Repl{{.T}}Store) ValueCap() (uint32, error) {
    type rettype struct {
        vcap uint32
        err  Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            vcap, err := s.ValueCap()
            if err != nil {
                ec <- &rettype{
                    vcap: vcap,
                    err: &repl{{.T}}StoreError{store: s, err: err},
                }
            } else {
                ec <- &rettype{vcap: vcap}
            }
        }(s)
    }
    vcap := uint32(math.MaxUint32)
    var errs Repl{{.T}}StoreErrorSlice
    for _ = range rs.Stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if ret.vcap < vcap {
            vcap = ret.vcap
        }
    }
    if len(errs) > 0 {
        return 0, errs
    }
    return vcap, nil
}

func (rs *Repl{{.T}}Store) Lookup(keyA, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}) (int64, uint32, error) {
    type rettype struct {
        timestampMicro int64
        length         uint32
        err            Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            timestampMicro, length, err := s.Lookup(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}})
            ret := &rettype{timestampMicro: timestampMicro, length: length}
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s, err: err}
            }
            ec <- ret
        }(s)
    }
    var timestampMicro int64
    var length uint32
    var errs Repl{{.T}}StoreErrorSlice
    var notFounds int
    // TODO: Selection algorithms
    for _ = range rs.Stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
            if store.IsNotFound(ret.err) {
                notFounds++
            }
        } else if ret.timestampMicro > timestampMicro {
            timestampMicro = ret.timestampMicro
            length = ret.length
        }
    }
    if notFounds > 0 {
        nferrs := make(Repl{{.T}}StoreErrorNotFound, len(errs))
        for i, v := range errs {
            nferrs[i] = v
        }
        return timestampMicro, length, nferrs
    }
    return timestampMicro, length, errs
}

func (rs *Repl{{.T}}Store) Read(keyA uint64, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}, value []byte) (int64, []byte, error) {
    type rettype struct {
        timestampMicro int64
        value          []byte
        err            Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            timestampMicro, value, err := s.Read(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}}, nil)
            ret := &rettype{timestampMicro: timestampMicro, value: value}
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s, err: err}
            }
            ec <- ret
        }(s)
    }
    var timestampMicro int64
    var rvalue []byte
    var errs Repl{{.T}}StoreErrorSlice
    var notFounds int
    // TODO: Selection algorithms
    for _ = range rs.Stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
            if store.IsNotFound(ret.err) {
                notFounds++
            }
        } else if ret.timestampMicro > timestampMicro {
            timestampMicro = ret.timestampMicro
            rvalue = ret.value
        }
    }
    if notFounds > 0 {
        nferrs := make(Repl{{.T}}StoreErrorNotFound, len(errs))
        for i, v := range errs {
            nferrs[i] = v
        }
        return timestampMicro, append(value, rvalue...), nferrs
    }
    return timestampMicro, append(value, rvalue...), errs
}

func (rs *Repl{{.T}}Store) Write(keyA uint64, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}, timestampMicro int64, value []byte) (int64, error) {
    type rettype struct {
        oldTimestampMicro int64
        err               Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            oldTimestampMicro, err := s.Write(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}}, timestampMicro, value)
            ret := &rettype{oldTimestampMicro: oldTimestampMicro}
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s, err: err}
            }
            ec <- ret
        }(s)
    }
    var oldTimestampMicro int64
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range rs.Stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if ret.oldTimestampMicro > oldTimestampMicro {
            oldTimestampMicro = ret.oldTimestampMicro
        }
    }
    return oldTimestampMicro, errs
}

func (rs *Repl{{.T}}Store) Delete(keyA uint64, keyB uint64{{if eq .t "group"}}, childKeyA, childKeyB uint64{{end}}, timestampMicro int64) (int64, error) {
    type rettype struct {
        oldTimestampMicro int64
        err               Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            oldTimestampMicro, err := s.Delete(keyA, keyB{{if eq .t "group"}}, childKeyA, childKeyB{{end}}, timestampMicro)
            ret := &rettype{oldTimestampMicro: oldTimestampMicro}
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s, err: err}
            }
            ec <- ret
        }(s)
    }
    var oldTimestampMicro int64
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range rs.Stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if ret.oldTimestampMicro > oldTimestampMicro {
            oldTimestampMicro = ret.oldTimestampMicro
        }
    }
    return oldTimestampMicro, errs
}

{{if eq .t "group"}}
func (rs *Repl{{.T}}Store) LookupGroup(parentKeyA, parentKeyB uint64) ([]store.LookupGroupItem, error) {
    type rettype struct {
        items []store.LookupGroupItem
        err   Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            items, err := s.LookupGroup(parentKeyA, parentKeyB)
            ret := &rettype{items: items}
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s, err: err}
            }
            ec <- ret
        }(s)
    }
    var items []store.LookupGroupItem
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range rs.Stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if len(ret.items) > len(items) {
            items = ret.items
        }
    }
    return items, errs
}

func (rs *Repl{{.T}}Store) ReadGroup(parentKeyA, parentKeyB uint64) ([]store.ReadGroupItem, error) {
    type rettype struct {
        items []store.ReadGroupItem
        err   Repl{{.T}}StoreError
    }
    ec := make(chan *rettype)
    for _, s := range rs.Stores {
        go func(s store.{{.T}}Store) {
            items, err := s.ReadGroup(parentKeyA, parentKeyB)
            ret := &rettype{items: items}
            if err != nil {
                ret.err = &repl{{.T}}StoreError{store: s, err: err}
            }
            ec <- ret
        }(s)
    }
    var items []store.ReadGroupItem
    var errs Repl{{.T}}StoreErrorSlice
    // TODO: Selection algorithms
    for _ = range rs.Stores {
        ret := <-ec
        if ret.err != nil {
            errs = append(errs, ret.err)
        } else if len(ret.items) > len(items) {
            items = ret.items
        }
    }
    return items, errs
}
{{end}}
